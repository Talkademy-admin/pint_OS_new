<div dir="rtl">

# تمرین گروهی ۱.۱ - مستند طراحی

گروه
-----
 > نام و آدرس پست الکترونیکی اعضای گروه را در این قسمت بنویسید.

یاشار ظروفچی <yasharzb@chmail.ir>

صبا هاشمی <sba.hashemii@gmail.com> 

امیرمحمد قاسمی <ghasemiamirmohammad@yahoo.com> 

مهرانه نجفی <najafi.mehraneh@gmail.com> 

مقدمات
----------
> اگر نکات اضافه‌ای در مورد تمرین یا برای دستیاران آموزشی دارید در این قسمت  بنویسید.

> لطفا در این قسمت تمامی منابعی (غیر از مستندات Pintos، اسلاید‌ها و دیگر منابع درس) را که برای تمرین از آن‌ها استفاده کرده‌اید در این قسمت بنویسید.

پاس‌دادن آرگومان
============
داده‌ساختار‌ها
----------------
> در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

در این بخش داده‌ساختار خاصی نیاز به طراحی نبود.

الگوریتم‌ها
------------
> به‌طور خلاصه توضیح دهید چگونه آرگومان‌ها را پردازش کرده‌اید؟ چگونه اعضای `argv[]` را به ترتیب درست در پشته قرار داده‌اید؟ و چگونه از سرریز پشته جلوگیری کرده‌اید؟
 
همانطور که انتظار می‌رفت و مطابق با روند دیباگ pintos مشاهده کردیم دو چالش اصلی پیش رو است

* جداسازی ورودی‌ها و آپشن‌های هر دستور خط‌فرمان
* مدیریت حافظه
  
برای رفع نیاز اول از تابع `strtok_r` استفاده خواهد شد. طبق مستند آن، طریقه‌ی به‌کاربردن آن به صورت زیر است:

<div dir="ltr">

```c
char *strtok_r(char *str, const char *delim, char **saveptr);
```
</div>

که در آن `str` رشته‌ی ورودی ماست. در مرحله‌ی اول، طبق `delim` که جداکننده است یک کلمه را جدا می‌کند و خروجی می‌دهد و باقی را در `saveptr` نگه می‌دارد. زین پس با هر بار صدا زدن این تابع با `str=NULL` و باقی پارامتر‌ها، کلمه به کلمه از `saveptr` جدا می‌کند خروجی می‌دهد. اکنون با هر بار اجرای pintos به صورت زیر

<div dir="ltr">

```bash
pintos -p </path/to/some/file> -a <cmd> -- -f -q run '<cmd> <inputs/options>'
```
</div>

عبارت پس از `run` را جدا می کند.

برای رفع چالش دوم نیاز است که تابع `setup_stack` را در اوایل تابع `load` که شالوده‌ی اجرای هر پردازه است (و در تابع `process.c:start_process()` قرار دارد) صدا بزنیم. پس از این عملیات، `esp` که اشاره‌گر به ابتدای فضای پشته‌ی کاربر است تعیین می‌شود. در هر نوبت از جداسازی پارامترهای دستور ورودی به pintos، آن‌ها را از انتها درون پشته قرار می‌دهیم (به کمک تابع `palloc_get_page` می‌توانیم اختصاص فضا را انجام دهیم) و سپس پردازه را اجرا می‌کنیم.
برای جلوگیری از سرریزی ابتدا چک می‌کنیم که آیا اضافه کردن آرگومان‌های دستور به پشته باعث مشکل می‌شود یا خیر. طبق مستند pintos ترتیب اضافه شدن به پشته به صورت زیر است (اعداد به بایت هستند)

* خود آرگومان‌ها از راست به چپ وارد می‌شوند (به صورت رشته‌ای که برابر با طول `file_name - argc` است)
* اعمال `stack-align (16)`
* وارد شدن اشاره‌گر به آرگومان‌ها (`argc * 4`)
* وارد شدن `argv` و `argc` (`8`)

پس درصورتی که این حجم کمتر از میزان فضای مجاز پشته بود خطا داده می‌شود.

منطق طراحی
-----------------
> چرا Pintos به‌جای تابع‌ `strtok()` تابع‌ `strtok_r()` را پیاده‌سازی کرده‌است؟

به‌علت اینکه `strtok_r` برخلاف `strtok` یک تابع ‍`thread safe` است.

> در Pintos عمل جدا کردن نام فایل از آرگومان‌ها، در داخل کرنل انجام می‌شود. در سیستم عامل‌های برپایه‌ی Unix، این عمل توسط shell انجام می‌شود. حداقل دو مورد از برتری‌های رویکرد Unix را توضیح دهید.

* جداسازی در `shell` از نظر امنیتی بهتر است چون می‌توان دسترسی‌های محدودتری داد.
* کد هسته ساده‌تر باقی می‌ماند.
* می‌توان مفسرهای متنوعی برای `shell` تعریف کرد و نیازی نیست برای هر کاربر کد هسته را تغییر داد.

فراخوانی‌های سیستمی
================
داده‌ساختار‌ها
----------------
> در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

به استراکت `thread` فیلدهای زیر را اضافه می‌کنیم:

<div dir="ltr">

```c
struct thread {
    ...

    tid_t parent_tid;

    struct semaphore exited;
    int exit_value;
    bool wait_on_called;
    struct semaphore can_free;    

    struct list children_list;
    struct list_elem child_elem;

    bool load_success_status;
    struct semaphore load_done;
    
    int fd_counter;
    struct list fd_list;
}
```
</div>

این اعضا در پیاده‌سازی سیستم کال‌ `wait` و `exec` و آزاد کردن منابع ترد کاربرد دارند:

- `parent_tid` شماره ترد پرنت است که برای چک کردن این که یک ترد بچه‌ی ترد دیگر است یا خیر استفاده می‌شود.
- ‍`exited` یک سمافور است که هنگام تمام شدن یک ترد up می‌شود و تردی که منتظر اتمام این ترد است آن را down می‌کند.
- `exit_value` خروجی ترد هنگام exit است.
- `wait_on_called` برای این است که بدانیم قبلا روی این ترد wait شده است یا خیر.
- `can_free` یک سمافور است که قبل از آزاد کردن استراکت ترد در صورت وجود پرنت برای ترد فعلی روی آن منتظر می‌مانیم. (down) ترد پرنت این سمافور را up می‌کند.
- `children_list` برای ذخیره‌ی لیست بچه‌های یک ترد استفاده می‌شود و برای up کردن `can_free` برای همه‌ی بچه‌ها کاربرد دارد.
- `child_elem` یک list_elem است و برای ذخیره‌ی ترد‌ها در لیست `children_list` استفاده می‌شود.
- `load_success_status` برای پردازه‌ها مشخص می‌کند بارگذاری فایل اجرایی موفق بوده است یا خیر.
- `load_done` یک سمافور برای این است که در exec منتظر بارگذاری برنامه‌ی اجرایی بمانیم.
- `fd_elem` لیست فایل‌هایی که توسط این ریسه باز است.
- `fd_counter` برای دادن شماره‌ی یکتا به توصیف‌کننده‌های فایل استفاده می‌شود.
- `fd_list` یک لیست است که برای ذخیره‌ی توصیف‌کننده‌های فایل باز یک پردازه استفاده می‌شود.



یک `struct` نیز برای توصیف کننده‌ی فایل ایجاد می‌کنیم:

<div dir="ltr">

```c
struct file_descriptor {
    struct file *file;
    int fd;
    struct list_ellem fd_elem;
}
```
</div>

در این استراکت شماره‌ی توصیف کننده‌ی فایل (`fd`) و فایل متناظر آن نگه‌داری می‌شود. هم چنین یک list_elem نیز در آن وجود دارد که برای ذخیره‌ی این داده ساختار در `fd_list` در استراکت ترد است.

> توضیح دهید که توصیف‌کننده‌های فایل چگونه به فایل‌های باز مربوط می‌شوند. آیا این توصیف‌کننده‌ها در کل سیستم‌عامل به‌طور یکتا مشخص می‌شوند یا فقط برای هر پردازه یکتا هستند؟

وقتی یک پرونده را باز می‌کنیم، به‌ازای هر کدام که باز هستند یک مدخل(entry) جایی در هسته قرار می‌گیرد که یک عدد Integer است. به این مداخل توصیف‌کننده‌ی پرونده گفته می‌شود.
می‌توان برای یک فایل باز چند توصیف‌کننده تعریف کرد (یعنی یک رابطه‌ی یک به یک وجود ندارد). همچنین این یکتایی به ازای هر پردازه برقرار است نه در تمام سیستم‌عامل.

الگوریتم‌ها
------------
> توضیح دهید خواندن و نوشتن داده‌های کاربر از داخل هسته، در کد شما چگونه انجام شده است.

برای خواندن و نوشتن داده‌های کاربر به این صورت عمل می‌کنیم:

- چون داده‌های کاربر را از روی استک می‌خوانیم، ابتدا چک می‌کنیم که خود استک پوینتر درون فضای کاربر باشد. هم چنین برای
این که مطمئن شویم همه‌ی آرگومان‌ها نیز درون فضای کاربر قرار دارند استک پوینتر + تعداد آرگومان‌ها را نیز چک می‌کنیم.


- در صورت معتبر بودن این فضا با استفاده از تابع `pagedir_get_page` در فایل `pagedir.c` آدرس مجازی کرنل را برای این حافظه به دست می‌آوریم. 
با چک کردن خروجی این تابع می‌توانیم مطمئن شویم که آدرس مجازی داده شده به یک آدرس واقعی مپ شده است یا خیر.

- در صورتی که بخواهیم عمل خواندن انجام دهیم، این قسمت از حافظه‌ را به حافظه‌ی کرنل کپی می‌کنیم. علت آن این است که کاربر در فاصله‌ی بین چک کردن آرگومان‌ها و استفاده از آن‌ها توسط کرنل نتواند تغییری در آرگومان‌ها ایجاد کند.

- حال برای هر کدام از آرگومان‌ها که یک پوینتر هستند نیز چک می‌کنیم که نال نباشند و در فضای کاربر قرار داشته باشند. در این صورت به طور مشابه بالا با استفاده از `pagedir_get_page` آدرس مجازی معادل را برای کرنل به دست می‌آوریم. و برای خواندن آن‌ها را به فضای کرنل کپی می‌کنیم. برای کپی کردن یک ماکسیمم طول مجاز در نظر می‌گیریم که مطمئن باشیم از فضای کاربر بیرون نمی‌زنیم و طول آرگومان‌ها نیز از حد معینی بیشتر نمی‌شود. برای نوشتن نیز ماکسیمم طول مجاز را در نظر می‌گیریم.

    هم چنین در این مرحله اطمینان حاصل می‌کنیم که رشته‌ها null terminated باشند. 
    

> فرض کنید یک فراخوانی سیستمی باعث شود یک صفحه‌ی کامل (۴۰۹۶ بایت) از فضای کاربر در فضای هسته کپی شود. بیشترین و کمترین تعداد بررسی‌‌های جدول صفحات (page table) چقدر است؟ (تعداد دفعاتی که `pagedir_get_page()` صدا زده می‌شود.) در‌ یک فراخوانی سیستمی که فقط ۲ بایت کپی می‌شود چطور؟ آیا این عددها می‌توانند بهبود یابند؟ چقدر؟

۴۰۹۶ بایت ماکسیمم می‌توانند در دو صفحه قرار بگیرند. برای همین می‌توانیم با باینری سرچ و استفاده از تابع `pg_no` یا با استفاده از تابع `pg_round_up` مکانی را که در آن وارد یک پیج دیگر می‌شویم پیدا کنیم. (این دو تابع نیاز به بررسی جدول صفحات ندارند و با استفاده از ۲۰ بیت پرارزش آدرس صفحه را مشخص می‌کنند.) پس از آن با ماکسیمم دو بار  استفاده از تابع گفته شده و بررسی جدول صفحات، می‌توانیم آدرس مجازی کرنل منتاظر با دو پیج کاربر را بگیریم و کپی را انجام دهیم.

برای ۲ بایت نیز مشابه بالا حداقل یک بار و حداکثر دوبار نیاز به استفاده از تابع `pagedir_get_page` وجود دارد. برای بهبود آن مثلا برنامه‌ی کاربر می‌تواند برای نوشتن در حافظه از آدرس‌های align شده استفاده کند.

> پیاده‌سازی فراخوانی سیستمی `wait` را توضیح دهید و بگویید چگونه با پایان یافتن پردازه در ارتباط است.

برای پیاده‌سازی `wait` ابتدا با استفاده از `children_list` که برای هر ترد نگه داشتیم چک می‌کنیم که آیا pid داده شده مربوط به تردی از فرزندان این پردازه می‌شود یا نه. در صورت نامعتبر بودن -۱ برمی‌گردانیم. هم چنین `wait_on_called` را نیز چک می‌کنیم تا در صورتی که قبلا روی این ترد `wait` صدا زده شده بود -۱ برگردانیم.

در غیر این صورت با استفاده از sema_down منتظر `exited` ترد فرزند می‌شویم. این سمافور در ترد فرزند پس از مقداردهی `exit_value` در ترد up می‌شود.

حال مقدار `exit_value` را می‌خوانیم و
پس از آن `can_free` ترد فرزند را sema_up می‌کنیم. پردازه‌ی فرزند قبل از این که ترد را در حالت `THREAD_DYING` قرار دهد منتظر این سمافور می‌ماند.
علت آن این است که پس از قرار داده شدن ترد در استیت گفته شده، scheduler ترد را از لیست‌ها حذف می‌کند و فضای مربوط به آن را آزاد می‌کند و در این صورت اگر پردازه‌ی فرزند زودتر از صدا زدن `wait` در parent به اتمام برسد دیگر به ترد فرزند و مقدار خروجی آن دسترسی نداریم. 

علت آن که در این مرحله می‌توانیم `can_free` فرزند را up کنیم این است که parent برای هر ترد فرزند فقط یک بار می‌تواند wait کند در نتیجه آزاد شدن حافظه‌های مربوط به فرزند مشکلی ندارد. هم چنین به همین دلیل `wait_on_called` را در ترد فرزند یک می‌کنیم تا در صورتی که دوباره روی این ترد `wait` انجام شد و هنوز ترد فرزند از لیست فرزندان حذف نشده بود بدانیم که قبلا روی آن `wait` کرده‌ایم.


> هر دستیابی هسته به حافظه‌ی برنامه‌ی کاربر، که آدرس آن را کاربر مشخص کرده است، ممکن است به دلیل مقدار نامعتبر اشاره‌گر منجر به شکست شود. در این صورت باید پردازه‌ی کاربر خاتمه داده شود. فراخوانی های سیستمی پر از چنین دستیابی‌هایی هستند. برای مثال فراخوانی سیستمی `write‍` نیاز دارد ابتدا شماره‌ی فراخوانی سیستمی را از پشته‌ی کاربر بخواند، سپس باید سه آرگومان ورودی و بعد از آن مقدار دلخواهی از حافظه کاربر را (که آرگومان ها به آن اشاره می کنند) بخواند. هر یک از این دسترسی ها به حافظه ممکن است با شکست مواجه شود. بدین ترتیب با یک مسئله‌ی طراحی و رسیدگی به خطا (error handling) مواجهیم. بهترین روشی که به ذهن شما می‌رسد تا از گم‌شدن مفهوم اصلی کد در بین شروط رسیدگی به خطا جلوگیری کند چیست؟ همچنین چگونه بعد از تشخیص خطا، از آزاد شدن تمامی منابع موقتی‌ای که تخصیص داده‌اید (قفل‌ها، بافر‌ها و...) مطمئن می‌شوید؟ در تعداد کمی پاراگراف، استراتژی خود را برای مدیریت این مسائل با ذکر مثال بیان کنید.

همانطور که در قسمت «بررسی خواندن و نوشتن داده‌های کاربر از هسته» آدرس‌ها و آرگمان‌ها بررسی می‌شوند که نال نباشند و به آن فضا دسترسی داشته باشیم، می‌توان تابعی برای چک کردن آرگمان‌هایی که در یک فراخوانی سیستمی (و یا در هر قسمتی از برنامه که به حافظه‌ای از برنامه‌ی کاربر نیاز داریم) استفاده می‌شود قرار داد که پیش از فراخوانی سیستمی (یا خواندن آن قسمت از حافظه‌ی برنامه‌ی کاربر)، نال نبودن و دسترسی داشتن به آدرس‌ها و مکانی که اشاره‌گرها به آن اشاره می‌کنند و در دسترس بودن کامل فضایی که یک آرگمان به آن اشاره می‌کند را بررسی کند.

مثلا در تابع load در پرونده‌ی process.c عملکرد مشابهی برای خواندن یک فایل در پیش گرفته شده و در صورت بروز مشکل (نبودن فایل مذکور ، دسترسی نداشتن به فضا و  ... ) به done پرش می‌کند و فایل را می‌بندد. با تابعی با عملکرد مشابه load پیش از عملی شدن دسترسی به حافظه‌ی برنامه‌ی کاربر و انتقال به کرنل می‌توان از بروز خطا در دسترسی به حافظه‌ی برنامه‌ی کاربر جلوگیری کنیم و در صورت بروز خطا منابع را آزاد و سپس پردازه را متوقف کنیم.

همگام‌سازی
---------------
> فراخوانی سیستمی `exec` نباید قبل از پایان بارگذاری فایل اجرایی برگردد، چون در صورتی که بارگذاری فایل اجرایی با خطا مواجه شود باید `-۱` برگرداند. کد شما چگونه از این موضوع اطمینان حاصل می‌کند؟ چگونه وضعیت موفقیت یا شکست در اجرا به ریسه‌ای که `exec` را فراخوانی کرده اطلاع داده می‌شود؟

برای این کار از سمافور `load_done` و فیلد `load_success_status` در داده ساختار ترد استفاده می‌کنیم. `load_success_status` در تابع `process_start` پس از صدا زدن تابع `load` مقداردهی می‌شود و مشخص می‌کند که آیا بارگذاری فایل موفق بوده یا نه. پس از آن `sema_up` برای `load_done` صدا زده می‌شود.

در تابع `exec` پس از ساختن پردازه و گرفتن tid با استفاده از تابع `process_execute`، در صورتی که tid برابر `TID_ERROR` باشد که مقدار -۱ را بازمی‌گرداند. در غیر این صورت ترد والد `sema_down` را برای `load_done` صدا می‌زند  و منتظر می‌ماند تا بارگذاری فایل اجرایی در ترد ساخته شده به اتمام برسد. پس از آن با توجه به مقدار `load_success_status` در صورتی که بارگذاری موفق نبوده باشد مقدار -۱ را به برنامه‌ای که `exec` را صدا زده برمی‌گرداند و در صورت موفقیت‌آمیز بودن شماره‌ی ترد را برمی‌گرداند.

> پردازه‌ی والد P و پردازه‌ی فرزند C را درنظر بگیرید. هنگامی که P فراخوانی `wait(C)` را اجرا می‌کند و C  هنوز خارج نشده است، توضیح دهید که چگونه همگام‌سازی مناسب را برای جلوگیری از ایجاد شرایط مسابقه (race condition) پیاده‌سازی کرده‌اید. وقتی که C از قبل خارج شده باشد چطور؟ 

با استفاده از سمافور `exited` در استراکت ترد فرزند این کار را انجام داده‌ایم. پردازه‌ی فرزند پس از قرار دادن `exit_value` ی خود در استراکت تردش، سمافور `exited` را up می‌کند. 
پردازه‌ی والد روی این سمافور down می‌کند. حال اگر از قبل پردازه‌ی فرزند به اتمام رسیده باشد یعنی قبلا این سمافور را up کرده و `wait‍‍` در پردازه‌ی والد می‌تواند مقدار خروجی را بخواند و خارج شود. اگر هم هنگام صدا زدن `wait` هنوز پردازه‌ی فرزند به اتمام نرسیده باشد، پردازه‌ی والد در همین جا منتظر اتمام پردازه و up شدن سمافور `exited` می‌ماند و پس از up شدن آن می‌تواند به `exit_value` فرزند بدون race condition دسترسی داشته باشد.

> (ادامه‌ی سوال قبل) در هر حالت چگونه از آزاد شدن تمامی منابع اطمینان حاصل می‌کنید؟ اگر P بدون منتظر ماندن، قبل از C خارج شود چطور؟ اگر بدون منتظر ماندن بعد از C خارج شود چطور؟ آیا حالت‌های خاصی وجود دارد؟

آزاد شدن page directory پردازه توسط صدا زده شدن تابع `process_exit` در تابع `thread_exit` بدون شرط خاصی انجام می‌شود. قسمتی که باید در آزاد کردن آن دقت بیشتری انجام دهیم خود استراکت ترد فرزند است، چون به آن برای پیاده‌سازی `wait` احتیاج داریم و نمی‌توانیم بدون هیچ شرطی آن را آزاد کنیم. در حالت فعلی پردازه‌ی فرزند استیت خود را در حالت `THREAD_DYING` قرار می‌دهد و پس از آن در scheduler هنگامی که به ترد بعدی برای اجرا سوییچ کردیم حافظه‌ی گرفته شده برای داده ساختار این ترد را آزاد می‌کند.

برای همین همان‌طور که در قسمت الگوریتم نیز کمی توضیح داده شد از یک سمافور `can_free` استفاده می‌کنیم. پردازه‌ی فرزند قبل از این که استیت خود را در حالت `THREAD_DYING` قرار دهد منتظر مثبت شدن این سمافور می‌شود. (sema_down)
این سمافور توسط پردازه‌ی والد در دو حالت up می‌شود:

 حالت اول وقتی است که `wait` را برای این پردازه صدا می‌کند. چون پس از آن دیگر به این پردازه احتیاجی نداریم و پردازه‌ی فرزند می‌تواند به اتمام برسد و منابع خود را آزاد کند. 

حالت دوم در `thread_exit` پردازه‌ی والد است. در این تابع برای همه‌ی بچه‌های ترد که در `children_list` قرار دارند این سمافور را up می‌کنیم چون پردازه‌ی والد به اتمام رسیده و دیگر روی هیچ کدام از بچه‌ها `wait` انجام نخواهد شد.

با این روش در هر صورت سمافور `can_free` up خواهد شد. حتی اگر پردازه‌ی والد kill شود نیز تابع `thread_exit` صدا زده می‌شود. پس در هر حالت پردازه‌های فرزند بالاخره یه استیت `THREAD_DYING` می‌رسند و حافظه‌های مربوط به آن‌ها آزاد می‌شود.


منطق طراحی
-----------------
> به چه دلیل روش دسترسی به حافظه سطح کاربر از داخل هسته را این‌گونه پیاده‌سازی کرده‌اید؟

در این پیاده‌سازی با چک کردن حالت‌هایی که ممکن است کاربر به فضای خارج از فضای خودش دسترسی داشته باشد از دسترسی غیر مجاز کاربر جلوگیری می‌شود. 
هم چنین با کپی کردن حافظه‌ی کاربر به کرنل از یک خطا به نام ‍*Time-of-check to time-of-use* جلوگیری می‌شود. 
با چک کردن آرگومان‌های فراخوانی‌های سیستمی نیز از مشکل‌هایی که ممکن است به خاطر این مسئله پیش بیاید (مثلا رشته‌ای که با صفر متوقف نشده)
جلوگیری می‌شود.

مزیت این روش نسبت به روش‌های دیگری که می‌توانستیم این کار را انجام دهیم (به طور مثال استفاده از اکسپشن page fault برای فهمیدن دسترسی غیر مجاز) 
صریح بودن آن است. 

> طراحی شما برای توصیف‌کننده‌های فایل چه نقاط قوت و ضعفی دارد؟

این طراحی برای رفع نیازمندی بسته‌شدن همه‌ی فایل‌های مربوط به یک ریسه پس از اتمام کار ریسه و همچنین ادامه‌دار بودن دسترسی یک پردازه‌ی خاص به فایلی (ولو پس از حذف آن) طراحی شده است. چون دقیقا می‌دانیم که هر پردازه در کدام فایل‌ها دخالت دارد.

> در حالت پیش‌فرض نگاشت `tid` به `pid` یک نگاشت همانی است. اگر این را تغییر داده‌اید، روی‌کرد شما چه نقاط قوتی دارد؟

تغییری در این فرض نداده‌ایم.

سوالات افزون بر طراحی
===========
> تستی را که هنگام اجرای فراخوانی سیستمی از یک اشاره‌گر پشته‌ی(esp) نامعتبر استفاده کرده است بیابید. پاسخ شما باید دقیق بوده و نام تست و چگونگی کارکرد آن را شامل شود.

تست `sc-bad-sp` همچین شرایطی را بررسی کرده است. این تست تلاش می‌کند یک فضای نامعتبر (یک آدرس بسیار منفی) را به `esp` منتقل کند. در نتیچه به‌علت عدم دسترسی به آن حافظه تست شکست می‌خورد.

> تستی را که هنگام اجرای فراخوانی سیستمی از یک اشاره‌گر پشته‌ی معتبر استفاده کرده ولی اشاره‌گر پشته آنقدر به مرز صفحه نزدیک است که برخی از آرگومان‌های فراخوانی سیستمی در جای نامعتبر مموری قرار گرفته اند مشخص کنید. پاسخ شما باید دقیق بوده و نام تست و چگونگی کارکرد آن را شامل شود.

تست `sc-boundary-3` این حالت را چک کرده است. به این صورت که ابتدا مرز را تشخیص می‌دهد. سپس یک پله باز در پشته پایین‌تر می‌رود (که موجب می‌شود خارج از ناحیه‌ی کاربری قرار گیرد). سپس چون مقدار ۱۰۰ را می‌نویسد یک بایت آن در قضای معتبر و یک بخش آن در فضای نامعتبر قرار می‌گیرد.

> یک قسمت از خواسته‌های تمرین را که توسط مجموعه تست موجود تست نشده‌است، نام ببرید. سپس مشخص کنید تستی که این خواسته را پوشش بدهد چگونه باید باشد.

در پوشه‌ی `tests/userprog` تستی برای `remove` مربوط به فایل وجود ندارد و برای اطمینان از عملکرد این فراخوانی لازم است که دست کم تستی داشته باشیم که همان حالت ادامه داشتن خواندن و نوشتن توسط پردازه‌های مرتبط با فایل را بررسی کند. همچنین ببیند که امکان باز کردن فایل برای پردازه‌های دیگر ناممکن است.


سوالات نظرخواهی
==============
پاسخ به این سوالات اختیاری است، ولی پاسخ به آن‌ها می‌تواند به ما در بهبود درس در ترم‌های آینده کمک کند. هر چه در ذهن خود دارید بگویید. این سوالات برای دریافت افکار شما هستند. هم‌چنین می‌توانید پاسخ خود را به صورت ناشناس در انتهای ترم ارائه دهید.

> به نظر شما، این تمرین یا هر یک از سه بخش آن، آسان یا سخت بودند؟ آیا وقت خیلی کم یا وقت خیلی زیادی گرفتند؟

> آیا شما بخشی را در تمرین یافتید که دید عمیق‌تری نسبت به طراحی سیستم عامل به شما بدهد؟

> آیا مسئله یا راهنمایی خاصی وجود دارد که بخواهید برای حل مسائل تمرین به دانشجویان ترم‌های آینده بگویید؟

> آیا توصیه‌ای برای دستیاران آموزشی دارید که چگونه دانشجویان را در ترم‌های آینده یا در ادامه‌ی ترم بهتر یاری کنند؟

> اگر نظر یا بازخورد دیگری دارید در این قسمت بنویسید.

</div>
