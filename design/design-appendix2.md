<div dir="rtl">

## donation

برای ترد ایکس:

یک لیستی از لاک‌هایی داریم که ایکس گرفته.

یک اولویت موثر هم براش داریم که فرض می‌کنیم تا الآن درسته.

حالا چه وقت‌هایی باید این آپدیت بشه؟:

1. یکی (یعنی خودش در واقع) با ست پرایوریتی تغییر بده اولویتش رو. در این صورت اولویت اصلیش باید تغییر کنه و ~~اولویت موثرش بشه ماکسیمم این و موثر فعلی.~~ باید دوباره حساب بشه این جوری ممکنه اشتباه بشه.

2. یک قفل جدید بگیره. در این صورت اولویت موثرش می‌شه ماکسیمم ماکسیمم اولویت *موثر* کسایی که الآن منتظر قفلن و موثر خودش. (که البته چون این قفل رو گرفته پس حتما اولویت موثرش بیشتر بوده از اون ها پس شاید بتونیم بگیم اصلا تغییری نمی‌کنه.)

3. یک نفر جدید بیاد منتظر یک قفلی که این منتظره. این جا باید دوباره اولویت موثرش رو با این اولویته ماکسیمم بگیریم.

4. یک قفل رو آزاد کنه. در این صورت باید بین ماکسیمم اولویت موثر همه‌ی کسایی که پشت یکی از قفل‌هاش منتظرن و اولویت خودش دوباره ماکسیمم گرفته بشه.

5. یکی از کسایی که منتظر قفل اینه اولویت موثرش تغییر کنه. نمی‌تونه کم شده باشه. چرا؟ چون یه ترد در این صورت‌ها اولویتش کم می‌شه:
    1. خودش تغییر بده با ست پرایوریتی
    2. اولویت موثرش مال خودش نباشه و یه قفلی رو آزاد کرده باشه و اولویتش دوباره کم شده باشه.
    
    حالا چون این ترده بلاکه پس نمی‌تونه هیچ کدوم از اینا اتفاق افتاده باشه پس اولویتش زیاد شده. در این حالت می‌تونیم دوباره اولویت ترد ایکس که لاک رو داره رو ماکسیمم بگیریم با اولویت موثر فعلیش.

~~پس می‌تونیم این کار رو کنیم که برای ترد ایکس یک لیست از لاک‌هایی که منتظرشونه هم نگه داریم و هر وقت اولویت~~ هر تردی فقط منتظر یک لاک می‌تونه باشه در آن واحد. در نتیجه می‌تونیم برای هر ترد اون قفلی که منتظرشه رو هم نگه داریم و اگر اولویتش آپدیت شد بریم برای هولدر اون قفله هم اولویتش رو آپدیت کنیم و بقیه‌ش به طور بازگشتی هندل می‌شه. منظور از این که اگر اولویتش آپدیت شد اینه که حتما تغییر کنه. اگر تغییر نکنه نمی‌ریم هولدر قفلش رو آپدیت کنیم که مشکل تو دور گیر کردن اینا هم نخوریم.

اگر این چیزها درست باشه دیگه برای گرفتن اولویت موثر کار پرهزینه‌ای لازم نداریم.

<div dir="ltr">

```c
void compare_priority_and_update(struct thread t, int priority); // usage for 5, 3
void calculate_priority_and_yield(struct thread t); // usage for 4, 1
```
</div>

مشکل:  synchronization ????


-----
## scheduling

دو جا به ready_list اضافه می‌شه. `thread_yield` و `thread_unblock`. فکر کنم باید چک شه که بعدش حتما ترد اولویت بالا اجرا شه. تو yield بعدش اسکژول می‌شه پس این هیچی فقط unblock.
</div>
