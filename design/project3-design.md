<div dir='rtl' text-align='justify'>

تمرین گروهی ۳ - مستند طراحی
======================

گروه
-----

>>‫نام و آدرس پست الکترونیکی اعضای گروه را در این قسمت بنویسید.

مقدمات
----------

>>‫ ‫‫اگر نکات اضافه‌ای در مورد تمرین یا برای دستیاران آموزشی دارید در این قسمت  ‫بنویسید.

>>‫ لطفا در این قسمت تمامی منابعی (غیر از مستندات Pintos، اسلاید‌ها و دیگر منابع‫ ‫درس) را که برای تمرین از آن‌ها استفاده کرده‌اید در این قسمت بنویسید.

بافر کش
============

داده‌ساختار‌ها و توابع
---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را‫ بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

در ابتدا یک ساختار به نام `cache` ایجاد می‌کنیم که به صورت زیر است

<div dir='ltr'>

```c
typedef struct cache {
    block_sector_t index;
    int is_dirty;
    int is_used;
    uni8_t *data;
    struct list_elem elem;
} cache;
void init_cache(void);
cache* get_cache(block_sector_t index);
void set_cache(block_sector_t index, unit8_t *buf);
void update_cache(cache* ca, unit8_t *buf, int offset, int size);
void remove_cache(cache* ca);
```
</div>
 
 همچنین یک ماکرو به نام `CACHE_BLK_SIZE` خواهیم داشت که مطابق مستند پروژه برابر با `64` خواهد بود.
 برای سهولت کار می‌توان لیستی از بلوک‌های کش‌شده را تحت نام `cached_blks` در فایل ‍`cache.c` نگه داشت.
  
همچنین تابع `byte_to_sector` نیز نیاز به تغییر دارد. زیرا نیاز داریم بررسی کنیم که آیا به صورت مستقیم یا بصورت غیرمستقیم مرتبه‌ی دو می‌بایست به بلوک دسترسی پیدا کینم.

الگوریتم‌ها
------------

>>‫ توضیح دهید که الگوریتم مورد استفاده‌ی شما به چه صورت یک بلاک را برای جایگزین ‫ شدن انتخاب می‌کند؟

در فایل `inode.c` ۲ تابع وجود دارد که در آن‌ها به حافظه‌ی نهان نیاز خواهیم داشت:

* `inode_read_at`
* `inode_write_at`

در تابع `inode_read_at` ابتدا با صدا زدن `get_cache` با بلوک موردنظر بررسی می‌کنیم که تاکنون به این `inode` حافظه‌ی نهان اختصاص داده شده است یا خیر. اگر شده بود که آن را می‌خوانیم در غیر این‌صورت یک کش متناظرا ایجاد می‌کنیم و بلوک موردنظر را می‌خوانیم.
ایضا روال مشابهی برای `inode_write_at` وجود دارد ولی درصورت وجود یک حافظه‌ی نهان از تابع `update_cache` استفاده می‌کنیم.

#### توضیح توابع `cache`

* `get_cache`: در لیست `cached_blks` پیمایش می‌کنیم تا حافظه‌ی نهان متناظر با بلوک داده شده به‌عنوان `index` یافت شود.
* `set_cache`: یک حافظه‌ی نهان ایجاد می‌کند که مقادیر `is_dirty` و `is_used` در آن به ترتیب ۰ و ۱ هستند. همچنین برای قرار دادن در صف اولویت از تابع `list_insert_ordered` استفاده می‌کنیم. ترتیب این حافظه‌های نهان نیز مبتنی بر `index` مربوط به بلوک است.
البته ممکن است که اندازه‌ی حافظه‌ی نهان فعلی از مقدار `CACHE_BLK_SIZE` گفته شده بیشتر باشد در این صورت الگوریتم ساعت را اجرا می‌کنیم.
* `update_cache`: صرفا مقادیر کپی می‌شوند و پرچم `is_dirty` به ۱ تغییر می‌یابد. زیرا طبق مستند، باید به صورت `write-back` عملیات نوشتن را انجام داد.

#### توضیح الگوریتم ساعت

همانطور که گفته شد در این پروژه بنا داریم تا الگوریتم ساعت را پیاده‌سازی کنیم. با توجه به امکانات خوب ساختار `list` کار بسیار ساده است. تنها کافی‌است تا پیش از رسیدن به یک بلوک استفاده شده هر حافظه‌ی نهانی که کثیف بود را `write_back` کنیم و پرچم `is_used` را ۰ کنیم.

##### نکات

* با توجه به مدیریت حافظه‌ی نهان و خواندن از بلوک‌ها هر جا سخن از خواندن/نوشتن مربوط به بلوک‌ها است منظور تابع پیاده‌سازی شده‌ی `block_write` و `block_read` ساختار تعبیه‌شده‌ی `block` است.

>>‫ روش پیاده‌سازی `read-ahead` را توضیح دهید.

 ابتدا یک تابع تحت نام `inode_read_ahead` تعریف می‌کنیم که ابتدا چک می‌کند برای بلوک مدنظر کش اختصاص دادیم یا خیر. درصورتی که حافظه‌ی نهانی وجود نداشت، به آن یک کش اختصاص می‌دهیم.
یک ریسه در انتهای `inode_read_at` قرار می‌دهیم که تابع `inode_read_ahead`  را پیاده‌سازی کند.

همگام سازی
-------------

>>‫ هنگامی که یک پردازه به طور مستمر در حال خواندن یا نوشتن داده در یک بلاک بافرکش‫ می‌باشد به چه صورت از دخالت سایر پردازه‌ها جلوگیری میشود؟

به بخش هماهنگ‌سازی پایین رجوع شود. پیاده‌سازی این سازوکار مربوط به خود `inode` است.

>>‫ در حین خارج شدن یک بلوک از حافظه‌ی نهان، چگونه از پروسه‌های دیگر جلوگیری می‌شود تا‫ به این بلاک دسترسی پیدا نکنند؟

ایضا

منطق طراحی
-----------------

>>‫ یک سناریو را توضیح دهید که از بافر کش، `read-ahead` و یا از `write-behind` استفاده کند.

* `read-ahead`: می‌توان یک توالی از بلوک‌های خوانده‌شده‌ی اخیر (مثلا ۳ تای اخیر) را نگه‌داشت تا هنگام صدا زدن تابع `inode_read_at`، درصورتی که این خواندن‌ها متوالی بودند؛ تابع `inode_read_ahead` را صدا زد.
* `write-behind`: با کمک `alarm` فاز قبل یک ریسه در ابتدا اجرا می‌کنیم که در بازه‌های زمانی مشخص اقدام به `write-back` کردن بافر‌های کثیف شود.

فایل‌های قابل گسترش
=====================

داده‌ساختار‌ها و توابع
---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری‫ یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و‫ دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

>>‫ بیشترین سایز فایل پشتیبانی شده توسط ساختار inode شما چقدر است؟

همگام سازی
----------

>>‫ توضیح دهید که اگر دو پردازه بخواهند یک فایل را به طور همزمان گسترش دهند، کد شما چگونه از‫ حالت مسابقه جلوگیری می‌کند.

>>‫ فرض کنید دو پردازه‌ی A و B فایل F را باز کرده‌اند و هر دو به end-of-file اشاره کرده‌اند.‫ اگر  همزمان A از F بخواند و B روی آن بنویسد، ممکن است که A تمام، بخشی یا هیچ چیز از‫ اطلاعات نوشته شده توسط B را بخواند. همچنین A نمی‌تواند چیزی جز اطلاعات نوشته شده توسط B را‫ بخواند. مثلا اگر B تماما ۱ بنویسد، A نیز باید تماما ۱ بخواند. توضیح دهید کد شما چگونه از‫ این حالت مسابقه جلوگیری می‌کند.

>>‫ توضیح دهید همگام سازی شما چگونه "عدالت" را برقرار می‌کند. فایل سیستمی "عادل" است که‫ خواننده‌های اطلاعات به صورت ناسازگار نویسنده‌های اطلاعات را مسدود نکنند و برعکس. بدین ترتیب‫ اگر تعدادی بسیار زیاد پردازه‌هایی که از یک فایل می‌خوانند نمی‌توانند تا ابد مانع نوشده شدن‫ اطلاعات توسط یک پردازه‌ی دیگر شوند و برعکس.

منطق طراحی
----------

>>‫ آیا ساختار `inode` شما از طبقه‌بندی چند سطحه پشتیبانی می‌کند؟ اگر بله، دلیل خود را برای‫ انتخاب این ترکیب خاص از بلوک‌های مستقیم، غیر مستقیم و غیر مستقیم دوطرفه توضیح دهید.‌‫ اگر خیر، دلیل خود برای انتخاب ساختاری غیر از طبقه‌بندی چند سطحه و مزایا و معایب ساختار‫ مورد استفاده خود نسبت به طبقه‌بندی چند سطحه را توضیح دهید.

زیرمسیرها
============

داده‌ساختار‌ها و توابع
---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری‫ یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و‫ دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

الگوریتم‌ها
-----------

>>‫ کد خود را برای طی کردن یک مسیر گرفته‌شده از کاربر را توضیح دهید.‫ آیا عبور از مسیرهای absolute و relative تفاوتی دارد؟

همگام سازی
-------------

>>‫ چگونه از رخ دادن race-condition در مورد دایرکتوری ها پیشگیری می‌کنید؟‫ برای مثال اگر دو درخواست موازی برای حذف یک فایل وجود داشته باشد و ‫ تنها یکی از آنها باید موفق شود یا مثلاً دو ریسه موازی بخواهند فایلی‫ یک اسم در یک مسیر ایجاد کنند و مانند آن.‫ آیا پیاده سازی شما اجازه می‌دهد مسیری که CWD یک ریسه شده یا پردازه‌ای‫ از آن استفاده می‌کند حذف شود؟ اگر بله، عملیات فایل سیستم بعدی روی آن‫ دایرکتوری چه نتیجه‌ای می‌دهند؟ اگر نه، چطور جلوی آن را می‌گیرید؟

منطق طراحی
-----------------

>>‫ توضیح دهید چرا تصمیم گرفتید CWD یک پردازه را به شکلی که طراحی کرده‌اید‫ پیاده‌سازی کنید؟

### سوالات نظرسنجی

پاسخ به این سوالات دلخواه است، اما به ما برای بهبود این درس در ادامه کمک خواهد کرد.

نظرات خود را آزادانه به ما بگوئید—این سوالات فقط برای سنجش افکار شماست.

ممکن است شما بخواهید ارزیابی خود از درس را به صورت ناشناس و در انتهای ترم بیان کنید.

>>‫ به نظر شما، این تمرین گروهی، یا هر کدام از سه وظیفه آن، از نظر دشواری در چه سطحی بود؟ خیلی سخت یا خیلی آسان؟

>> چه مدت زمانی را صرف انجام این تمرین کردید؟ نسبتا زیاد یا خیلی کم؟

>>‫ آیا بعد از کار بر روی یک بخش خاص از این تمرین (هر بخشی)، این احساس در شما به وجود آمد که اکنون یک دید بهتر نسبت به برخی جنبه‌های سیستم عامل دارید؟

>>‫ آیا نکته یا راهنمایی خاصی وجود دارد که بهتر است ما آنها را به توضیحات این تمرین اضافه کنیم تا به دانشجویان ترم های آتی در حل مسائل کمک کند؟

>> متقابلا، آیا راهنمایی نادرستی که منجر به گمراهی شما شود وجود داشته است؟

>>‫ آیا پیشنهادی در مورد دستیاران آموزشی درس، برای همکاری موثرتر با دانشجویان دارید؟

این پیشنهادات میتوانند هم برای تمرین‌های گروهی بعدی همین ترم و هم برای ترم‌های آینده باشد.

>>‫ آیا حرف دیگری دارید؟

</div>